// weakRef
// 애초에 참조 래퍼런스를 할당하지 않아서
// GC가 돌때 무조건 갈아버리는!!

const await = 'asd';
console.log(await);

// 값 => 표현식이 평가되어 생성된 결과
// 10+20 => 표현식
// 30 => 값 (변수에 할당)


// 리터럴
// 2진수 => 0b (bin)
// 8진수 => 0o (oct)
// 16진수 => 0x (hex)

// 표현식 => "값으로 평가될 수 있는" 문.
// 평가가 진행되면 "값이 있어야 한다."
// 값으로 평가될 수 있다면 "모두 표현식" (리터럴, 식별자, 연산자, 함수 등)
// 이때 표현식과 값은 동치

// ASI: 세미콜론 자동 삽입 기능
// 그리 중요하다기 보다는 간혹 오류가 나오는 경우가 있다고 함.

// 할당문은 그 자체로 표현식이면서 문이다..?
// 그래서 x = 100 은 표현식으로 쳐준다?
// x = 100 위 문은 평가가 진행되면 값이 100으로 쳐준다는 것 같음

// 아래 막 써보면서 느낀건데
var foo = x = 100 
// 위 문은 사실상
var x = 100;
var foo = x;
// 위와 같은데, x라는 변수를 불러오는 건 식별자 표현식에 해당하므로 맞을듯! 

// 표현식
x = 100 // 값: 100
10 + 20 // 값: 30

const b = 20;
b + 30 // 값: 50

const data = 30; // 미리 선언했다면
data // 이 식별자(변수) 자체도 표현식이다.

// 문 => 토큰들의 조합